<html>
  <head>
    <title>Blog - canhazdb</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="/img/favicon.png">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/atom-one-dark.min.css" integrity="sha512-Fcqyubi5qOvl+yCwSJ+r7lli+CO1eHXMaugsZrnxuU4DVpLYWXTVoHy55+mCb4VZpMgy7PBhV7IiymC0yu9tkQ==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js" integrity="sha512-zol3kFQ5tnYhL7PzGt0LnllHHVWRGt2bTCIywDiScVvLIlaDOVJ6sPdJTVi0m3rA660RT+yZxkkRzMbb1L8Zkw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/languages/javascript.min.js" integrity="sha512-u9dJCEIlcxWLWzlBIBDAO98TI5r1yrxGwRY2vbqFdecd58lamsEgBt1p4sDNBncNUMDV5//WdywRHdhCLx0FJQ==" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="/css/header.css" />
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />

    <script>
      document.addEventListener('DOMContentLoaded', (event) => {
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightBlock(block);
        });
      });

      function toggleBurgerMenu () {
        document.body.classList.toggle('burger-open');
      }
    </script>
    <base href="/" />

    <link rel="icon" type="image/png" href="/img/favicon.png" />
  </head>

  <body>
    <header class="menu-header">
      <div class="header-container">
        <div class="header-brand">
          <a href="/">
            <img src="/img/logo.svg" class="logo-icon" />
            <span>canhazdb</span>
          </a>
        </div>
        <div class="header-burger" onclick="toggleBurgerMenu()">
          <svg viewBox="0 0 100 80" width="25" height="25">
            <rect width="100" height="10"></rect>
            <rect y="30" width="100" height="10"></rect>
            <rect y="60" width="100" height="10"></rect>
          </svg>
        </div>
        
    <nav class="bugerable">
      <a href="/" false>Home</a>
      <a href="/docs" false>Docs</a>
      <a href="/blog" class="active">Blog</a>
      <a href="https://github.com/canhazdb/server/discussions">Community</a>
    </nav>
  
      </div>
    </header>

    <main>
      <div class="with-sidebar"><div class="thin content"><sidebar><ul><li><span>October 2021</span><ul><li><span>1</span><a href="/blog/2021/09/01/conflicts">Conflicts</a></li></ul></li><li><span>August 2021</span><ul><li><span>15</span><a href="/blog/2021/07/15/notify-and-license">Notify and license</a></li><li><span>11</span><a href="/blog/2021/07/11/ha-update">Ha update</a></li></ul></li><li><span>June 2021</span><ul><li><span>15</span><a href="/blog/2021/05/15/reducing-noise">Reducing noise</a></li><li><span>5</span><a href="/blog/2021/05/05/performance-bug">Performance bug</a></li><li><span>1</span><a href="/blog/2021/05/01/websockets-insert">Websockets insert</a></li></ul></li><li><span>May 2021</span><ul><li><span>23</span><a href="/blog/2021/04/23/stability">Stability</a></li></ul></li><li><span>February 2021</span><ul><li><span>8</span><a href="/blog/2021/01/08/introduction">Introduction</a></li></ul></li></ul></sidebar><section><div class="content-heading"><h1>Conflicts<small>Published by <a href="https://markwylde.com" target="_blank">Mark Wylde</a> on 2021-10-01</small></h1><div class="content-info"><a target="_blank" class="edit-page" href="https://github.com/canhazdb/documentation/blob/master/content/blog/2021-10-01-conflicts.md">Edit this page</a></div></div><div><p>I&#39;ve been slowly working through the last of the issues and feel like version 8 is very close to getting merged into master and released.</p>
<h1 id="conflicts">Conflicts</h1>
<p>Conflict&#39;s have been completed, and will now attempt to resolve when a node recovers. The cleanup logic took a lot longer than I thought, but due to my own over complication of the strategy.</p>
<p>While resolving conflicts was as easy as letting all other nodes know about the resolution, and syncing with other nodes on startup, the deletion was trickier. We can only delete a conflict, once all other nodes have successfully received the conflict resolutions.</p>
<p>I&#39;m sure there are improvements that can be made to the efficiency of the conflict implementation, but I&#39;m happy that for now conflicts seem to be working well.</p>
<h1 id="system-collections">System Collections</h1>
<p>The main system collections have been implemented:</p>
<ul>
<li><code>system.collections</code></li>
<li><code>system.notifys</code></li>
<li><code>system.locks</code></li>
<li><code>system.nodes</code></li>
</ul>
<p>The schema has changed a little from my initial idea, but the main information is still there.</p>
<p>It did identify one issue that I need to seed the system collections to the <code>system.collections</code>. I don&#39;t want to hard code this in, and would prefer each module is responsible for its own seeding.</p>
<p>But as there isn&#39;t the concept of &quot;installing&quot; the database, I might have to just check on every node start, if the collection has been added. It seems a little inefficient, but efficiency can be improved later.</p>
<h1 id="http-endpoints">Http Endpoints</h1>
<p>The http server for issue <a href="https://github.com/canhazdb/server/issues/61">#61</a> has been implemented, but I&#39;ve only managed to write the get collections and get documents endpoints. It went pretty smoothly, and I hope the other endpoints will not take too long.</p>
<h1 id="required-certs">Required Certs</h1>
<p>I&#39;ve been trying to keep both <code>TLS</code> and <code>unencrypted tcp</code> to allow for easier development environments. But I&#39;m becoming more uncomfortable with having this mix and match of tcp/http that can be secure or insecure. Plus, the NodeJS http2 library doesn&#39;t support none TLS communication.</p>
<p>Therefore, certs/TLS is now required for all instances running. You will not be able to connect to the http or TLS ports without full TLS validation.</p>
<p>The one exception will be the web UI client. That will use the same certs and be delivered over TLS, but it will not verify the client certificate. This means, you can access the web UI in your browser, but not the http api endpoints.</p>
<h1 id="next">Next</h1>
<p>Currently, I&#39;m working on finishing the http endpoints, then will put a simple version check to ensure all nodes are on the same major version.</p>
<p>That will complete the last of the issues for the v8 release.</p>
<p>But before I merge and release, I need to properly update the documentation. Most importantly, I want to document the &quot;canhazdb protocol&quot;.</p>
</div><hr><div class="content-heading"><h1>Notify and License<small>Published by <a href="https://markwylde.com" target="_blank">Mark Wylde</a> on 2021-08-15</small></h1><div class="content-info"><a target="_blank" class="edit-page" href="https://github.com/canhazdb/documentation/blob/master/content/blog/2021-08-15-notify-and-license.md">Edit this page</a><em>Last updated: 2021-10-01</em></div></div><div><p>I&#39;ve just finished implementing the notify logic. Logic has now been implemented to detect a temporary primary replica called <code>isDocumentPrimaryReplica</code>.</p>
<p>This can be used from an internal controller, when an action should be performed only once per internal method. For example:</p>
<ol>
<li>When you have <code>PATCH</code>ed 1 document that has 3 replicas, it should only <code>NOTIFY</code> once.</li>
<li>When you need to return the effected documents (not replicas).</li>
</ol>
<p>The current logic is:</p>
<pre><code class="language-javascript">function isDocumentPrimaryReplica (context, document) {
  return document._replicatedNodes[0] === context.thisNode.name;
}
</code></pre>
<p>But ideally, this needs to <em>also</em> take into consideration if the actual primary replica is offline/unhealthy. I&#39;ll get to that later.</p>
<h2 id="license-change">License change</h2>
<p>The main project is deliberately licensed as <a href="https://github.com/canhazdb/server/blob/master/LICENSE">AGPL-3</a>, but I realised the client library was also licensed as AGPL-3 too.</p>
<p>That was not my intention. If you want to use the canhazdb client library, you do not have to release your entire app as AGPL-3. For example, if you run a canhazdb server cluster, and then build a separate app that talks to the server (either using the client library or your own), the project does not have to be licensed as <a href="https://github.com/canhazdb/server/blob/master/LICENSE">AGPL-3</a>.</p>
<p>Therefore, I have changed the <a href="https://github.com/canhazdb/client">canhazdb client</a> license to be <a href="https://github.com/canhazdb/client/blob/master/LICENSE">MIT</a>.</p>
<p>Note, the license of the <a href="https://github.com/canhazdb/client">canhazdb server</a> is still <a href="https://github.com/canhazdb/server/blob/master/LICENSE">AGPL-3</a>. The intention being, if you make any changes to the server or embed it into another product, the project should be licensed as <a href="https://github.com/canhazdb/server/blob/master/LICENSE">AGPL-3</a> and source code released.</p>
<h2 id="next---statistics">Next - Statistics</h2>
<p>The last major feature for me to implement is the <code>system.collections</code> collection. I&#39;ll try to get that completed this week.</p>
<p>Once that&#39;s finished, I&#39;m going to embed a very simple http server (without websocket notify support). Then finally, I can get the <a href="https://github.com/canhazdb/server/tree/ha">ha branch</a> into master. Milestone reached!</p>
</div><hr><div class="content-heading"><h1>High Availability Update<small>Published by <a href="https://markwylde.com" target="_blank">Mark Wylde</a> on 2021-08-11</small></h1><div class="content-info"><a target="_blank" class="edit-page" href="https://github.com/canhazdb/documentation/blob/master/content/blog/2021-08-11-ha-update.md">Edit this page</a><em>Last updated: 2021-10-01</em></div></div><div><p>Over the past few months I&#39;ve not had the chance to work on canhazdb as much as I&#39;d like, as my projects that use the first prototype (version 7) are still working really well.</p>
<p>But over the last week, I finally got some time to implement events, known as <code>notify</code>.</p>
<h2 id="notify">Notify</h2>
<p>The syntax is still the same as before, but the protocol has now been updated to:</p>
<ol>
<li>Use the new lightweight byte syntax, as described in my last blog post</li>
<li>Each <code>NOTIFY_ON</code> can only have one <code>NOTIFY_PATH</code></li>
</ol>
<p>It&#39;s working really well, at least for <code>post</code>&#39;s. I still have some work to do to get <code>put</code>, <code>patch</code>, <code>delete</code> working. These are a little more tricky as one command can mutate multiple documents. With a <code>post</code>, it will only mutate one.</p>
<h2 id="count">Count</h2>
<p>The <code>count</code> command was very easy to implement. It&#39;s basically the same logic as a <code>get</code>, but instead of returning the documents, it returns just the number from each server.</p>
<h2 id="lock">Lock</h2>
<p>Before I could implement the <code>put</code>, <code>patch</code> and <code>delete</code> commands we need locking.</p>
<p>I&#39;m not entirely sure if this lock is needed. But because these commands trigger updates on <em>multiple</em> document replicas, I feel it&#39;s important that all replicas contain the same value.</p>
<p>So for now, when one of these three commands is sent, a lock will be placed on the collection while all documents are mutated, and then removed once complete.</p>
<p>I feel like when transactions are implemented further down the line, this could be removed, or at least change shape in some way.</p>
<h2 id="put-patch-delete">Put, Patch, Delete</h2>
<p>The <code>put</code>, <code>patch</code> and <code>delete</code> commands are similar to a <code>post</code>, but instead of choose three random servers to insert a document, we must go out to all servers and request updates.</p>
<p>With the built in $REPLICATION_FACTOR (currenly 3), if you have 3 or more servers, then each document will be inserted on each of the 3 servers.</p>
<p>So when one of these commands is issued externally, the server looks up every server in the cluster, and forwards the command.</p>
<p>The internal server needs to reply with the number of changes it made. However, it can&#39;t simply send how many document where updated. If we have 3 documents, each replicated 3 times, then our total change count would be 9.</p>
<p>Instead, the internal server will only respond with the documents it changed, where it was the first &quot;online&quot; server in the <code>_replicatedNodes</code> property.</p>
<h2 id="system-statistics">System Statistics</h2>
<p>The <code>system.tables</code> collection has not been implemented at all. I think it will be pretty easy to implement, as most of the logic from v7 can be carried over.</p>
</div><hr><div class="content-heading"><h1>Reducing Noise<small>Published by <a href="https://markwylde.com" target="_blank">Mark Wylde</a> on 2021-06-15</small></h1><div class="content-info"><a target="_blank" class="edit-page" href="https://github.com/canhazdb/documentation/blob/master/content/blog/2021-06-15-reducing-noise.md">Edit this page</a><em>Last updated: 2021-10-01</em></div></div><div><p>I&#39;ve been wanted to get high availability into canhazdb for quite a while now, but I had been unsure of exactly how I was going to implement it.</p>
<p>There&#39;s still some unknowns, but in general I feel I&#39;ve got a good idea of where I want it to go.</p>
<p>This week I started a new branch, which is essentially a complete rewrite of the server.</p>
<p>Some major changes are in that branch:</p>
<h2 id="no-httpswss-servers">No http(s)/ws(s) servers</h2>
<p>When I wrote the first version, I kept juggling between the http(s) server, and the tcp servers. I decided for the rewrite, they really shouldn&#39;t have anything to do with each other.</p>
<p>I still want canhazdb to come with the option of a lightweight http server, but I&#39;ll put it in at the end, and it&#39;ll be abstracted out a lot more.</p>
<h2 id="protocol-rewrite">Protocol rewrite</h2>
<p>The current stable version talks exclusively over JSON. So every time a node is asked to do something, it must receive the command in JSON and send a respones in JSON.</p>
<p>I still believe the biggest risk to the theory of canhazdb is network noise. Specially the noise of nodes that have no data to send back.</p>
<p>For example, when filtering on records (GET:/exampleCollection), a request is sent out to all nodes. In the current version is looks like this:</p>
<pre><code class="language-json">[10, {
  &quot;COMMAND&quot;: &quot;GET&quot;,
  &quot;COLLECTION_ID&quot;: &quot;exampleCollection&quot;,
  &quot;LIMIT&quot;: 10
}]
</code></pre>
<p>| n.b. the keys are shorted into numbers, but you get the idea.</p>
<p>In the latest version of <a href="https://github.com/markwylde/tcpocket">tcpocket</a>, I&#39;ve reduced the protocol to be a pure buffer. At least, for the first 3 bytes.</p>
<p>The above turns into:</p>
<pre><code class="language-text">&lt;Buffer&gt;[0x01, 0x00, 0x09, ...optionalBufferSegments]
</code></pre>
<p>The first two bytes make up an <code>Int16Array</code>, which resolves to the correlation id (a number between 3 and 65535), to allow for request and responses. The third byte is a command (an <code>Int8Array</code>) which is a number between 2 and 255.</p>
<p>Look back at the <code>GET</code> example above, this will make the request a little smaller.</p>
<p>But I feel the main benefit comes from the response, especially for nodes with no information to return.</p>
<p>Currently if a node does not have any results to send, it returns:</p>
<pre><code class="language-json">[10, {
  &quot;STATUS&quot;: &quot;200&quot;,
  &quot;DOCUMENTS&quot;: []
}]
</code></pre>
<p>With the new protocol, a node with no results to give can send:</p>
<pre><code class="language-text">&lt;Buffer&gt;[0x01, 0x00, 0x06]
</code></pre>
<p>This would mean for a filter that has to go out to a cluster of (for example) 10 nodes, if only 1 node has the document we are looking for, we have only wasted 9 bytes in the response.</p>
<p>There is much more to do on this, but I&#39;m pretty happy so far. I have even noticed an improvement in the test speeds.</p>
<h2 id="high-availability">High Availability</h2>
<p>With the rewrite, I&#39;ve currently implemented the <code>info</code>, <code>get</code>, and <code>post</code> commands.</p>
<h3 id="posts">POST&#39;s</h3>
<p>Performing a <code>POST</code> is one of the easiest commands on a database. The logic is basically, select $REPLICATION_FACTOR nodes at random (default 3), and insert the document.</p>
<p>Along with the document, each node is also told about all other nodes holding that replica.</p>
<h3 id="gets">GET&#39;s</h3>
<p>When performing a <code>GET</code>, the request still gets forwarded to every node in the cluster. However, now, a node will only return a document, if they are the first healthy node in the documents replica list.</p>
<p>So far this is all working really well, and I&#39;m happy with the performance (for now).</p>
<p>My next steps will be to implement locking again (as this is needed for PUT/PATCH/DELETE&#39;s), and then implement the rest of the commands.</p>
<h2 id="ejdb-vs-sqlite">EJDB vs SQLite</h2>
<p>One thing that&#39;s been bothering me about EJDB is the restriction on indexing.</p>
<p>Every field is indexed in canhazdb, and EJDB supports really good and fast indexing. However, you can only use them under certain conditions.</p>
<p>For this reason I&#39;m considering testing SQLite again, but using a different strategy from last time. I&#39;m concerned though that the overhead of a relational database engine will give a considerable performance loss. But I think it&#39;s worth a test.</p>
<p>Failing that, I might raise an issue with the EJDB author to find out any better solution for filtering on multiple indexes.</p>
</div><hr><div class="content-heading"><h1>Performance Bug<small>Published by <a href="https://markwylde.com" target="_blank">Mark Wylde</a> on 2021-06-05</small></h1><div class="content-info"><a target="_blank" class="edit-page" href="https://github.com/canhazdb/documentation/blob/master/content/blog/2021-06-05-performance-bug.md">Edit this page</a><em>Last updated: 2021-10-01</em></div></div><div><p>For the last few months <a href="https://docs.puzed.com/">Puzed</a>, which uses Canhazdb, has been slowing down as time passes. This bug would cause an instance to crash at least once a day.</p>
<p>I had tried on and off to debug this over the past six months, but my focus was mainly on the Puzed project. This is because Puzed has so much logic, scheduled jobs, healthchecks and more. I was certain there was a leak somewhere in that code.</p>
<p>But as I mentioned in my previous blog post, I wanted to stress test Canhazdb on it&#39;s own to see what it&#39;s limitations are.</p>
<p>Starting on Puzed, I added some metrics monitoring to the project. This resulted in the following:</p>
<h2 id="1-puzed-performance">1) Puzed Performance</h2>
<p><img src="/img/blog-performance-bug-1.png" alt="screenshot of metrics"></p>
<p>The above is a snapshot showing the different type of database requests, along with the average time (in milliseconds) it took to complete the request.</p>
<p>You can see, it gradually takes longer and longer to perform essentially the same number of queries.</p>
<h2 id="2-canhazdb-performance">2) Canhazdb Performance</h2>
<p><img src="/img/blog-performance-bug-2.png" alt="screenshot of metrics"></p>
<p>After a while drilling into the Puzed codebase, I decided to just trying the same metrics testing in a local Canhazdb instance instead.</p>
<p>To my surprise, Canhazdb was showing similar performance degregation.</p>
<p>Luckily, the first part of the stack I looked at, was the client. It didn&#39;t take too long to until I discovered <a href="https://github.com/canhazdb/client/commit/cc4e16c859231720bdbc87410ab47a2048221efc">a bug in the client</a>. Everytime a message is sent to the server, it waits for a response. Once it receives a response, I wasn&#39;t cleaning up the callbacks. This was resulting in a huge array that could never empty.</p>
<h2 id="3-performance-after-fix">3) Performance after fix</h2>
<p><img src="/img/blog-performance-bug-3.png" alt="screenshot of metrics"></p>
<p>Finally, with the fix inplace, it looks like the performance is stable and consistent.</p>
<h2 id="4-puzed-upgrade">4) Puzed upgrade</h2>
<p><img src="/img/blog-performance-bug-4.png" alt="screenshot of metrics"></p>
<p>Finally, I upgraded the Canhazdb client dependency in the Puzed API server. This resulted, not only in much lower response times, but the beta server is now up and running for much longer than normal, along with consistent, linear response times.</p>
</div><hr></section></div></div>
    </main>
  </body>
</html>
